/* tslint:disable */
/* eslint-disable */
/**
 * API de Controle de Estoque - Vortex
 * API RESTful para gerenciamento completo de estoque, incluindo cadastro de produtos, tipos de produtos, movimentações de entrada e saída, e geração de relatórios. Desenvolvida como parte do desafio FullStack da Vortex.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dev@vortex.com.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * DTO para o relatório de lucro por produto
 * @export
 * @interface LucroPorProdutoDTO
 */
export interface LucroPorProdutoDTO {
    /**
     * ID do produto
     * @type {number}
     * @memberof LucroPorProdutoDTO
     */
    'id'?: number;
    /**
     * Descrição do produto
     * @type {string}
     * @memberof LucroPorProdutoDTO
     */
    'descricao'?: string;
    /**
     * Total de unidades vendidas
     * @type {number}
     * @memberof LucroPorProdutoDTO
     */
    'totalUnidadesVendidas'?: number;
    /**
     * Lucro total
     * @type {number}
     * @memberof LucroPorProdutoDTO
     */
    'lucroTotal'?: number;
}
/**
 * Representa um movimento de estoque (entrada ou saída)
 * @export
 * @interface MovimentoEstoque
 */
export interface MovimentoEstoque {
    /**
     * Identificador único do movimento de estoque (gerado automaticamente)
     * @type {number}
     * @memberof MovimentoEstoque
     */
    'id'?: number;
    /**
     * Data e hora em que o movimento foi registrado (gerado automaticamente)
     * @type {string}
     * @memberof MovimentoEstoque
     */
    'dataMovimento'?: string;
    /**
     * Tipo de movimentação (ENTRADA aumenta o estoque, SAIDA diminui o estoque)
     * @type {string}
     * @memberof MovimentoEstoque
     */
    'tipoMovimentacao': MovimentoEstoqueTipoMovimentacaoEnum;
    /**
     * Quantidade de itens movimentados (deve ser maior que zero)
     * @type {number}
     * @memberof MovimentoEstoque
     */
    'quantidadeMovimentada': number;
    /**
     * Valor de venda unitário (calculado automaticamente para SAIDA como 1.35 * valorFornecedor, nulo para ENTRADA)
     * @type {number}
     * @memberof MovimentoEstoque
     */
    'valorVenda'?: number;
    /**
     * Identificador do produto associado ao movimento
     * @type {number}
     * @memberof MovimentoEstoque
     */
    'produtoId': number;
}

export const MovimentoEstoqueTipoMovimentacaoEnum = {
    Entrada: 'ENTRADA',
    Saida: 'SAIDA'
} as const;

export type MovimentoEstoqueTipoMovimentacaoEnum = typeof MovimentoEstoqueTipoMovimentacaoEnum[keyof typeof MovimentoEstoqueTipoMovimentacaoEnum];

/**
 * DTO para transferência de dados de Produto
 * @export
 * @interface ProdutoDTO
 */
export interface ProdutoDTO {
    /**
     * ID do produto
     * @type {number}
     * @memberof ProdutoDTO
     */
    'id'?: number;
    /**
     * Descrição do produto
     * @type {string}
     * @memberof ProdutoDTO
     */
    'descricao': string;
    /**
     * Valor do fornecedor
     * @type {number}
     * @memberof ProdutoDTO
     */
    'valorFornecedor': number;
    /**
     * Quantidade em estoque
     * @type {number}
     * @memberof ProdutoDTO
     */
    'quantidadeEmEstoque'?: number;
    /**
     * ID do tipo de produto
     * @type {number}
     * @memberof ProdutoDTO
     */
    'tipoProdutoId': number;
}
/**
 * DTO para o relatório de produtos por tipo
 * @export
 * @interface ProdutoPorTipoDTO
 */
export interface ProdutoPorTipoDTO {
    /**
     * ID do produto
     * @type {number}
     * @memberof ProdutoPorTipoDTO
     */
    'id'?: number;
    /**
     * Descrição do produto
     * @type {string}
     * @memberof ProdutoPorTipoDTO
     */
    'descricao'?: string;
    /**
     * Quantidade total de saídas
     * @type {number}
     * @memberof ProdutoPorTipoDTO
     */
    'totalSaidas'?: number;
    /**
     * Quantidade em estoque
     * @type {number}
     * @memberof ProdutoPorTipoDTO
     */
    'quantidadeEmEstoque'?: number;
}
/**
 * DTO para transferência de dados de Tipo de Produto
 * @export
 * @interface TipoProdutoDTO
 */
export interface TipoProdutoDTO {
    /**
     * ID do tipo de produto
     * @type {number}
     * @memberof TipoProdutoDTO
     */
    'id'?: number;
    /**
     * Nome do tipo de produto
     * @type {string}
     * @memberof TipoProdutoDTO
     */
    'nome': string;
}

/**
 * MovimentosDeEstoqueApi - axios parameter creator
 * @export
 */
export const MovimentosDeEstoqueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cria um novo movimento de estoque com os dados fornecidos
         * @summary Cria um novo movimento de estoque
         * @param {MovimentoEstoque} movimentoEstoque 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovimento: async (movimentoEstoque: MovimentoEstoque, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movimentoEstoque' is not null or undefined
            assertParamExists('createMovimento', 'movimentoEstoque', movimentoEstoque)
            const localVarPath = `/movimentos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movimentoEstoque, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exclui um movimento de estoque existente pelo seu ID
         * @summary Exclui um movimento de estoque
         * @param {number} id ID do movimento de estoque a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMovimento: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMovimento', 'id', id)
            const localVarPath = `/movimentos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna uma lista com todos os movimentos de estoque cadastrados
         * @summary Busca todos os movimentos de estoque
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMovimentos: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/movimentos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna um movimento de estoque específico pelo seu ID
         * @summary Busca um movimento de estoque pelo ID
         * @param {number} id ID do movimento de estoque a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovimentoById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findMovimentoById', 'id', id)
            const localVarPath = `/movimentos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Atualiza um movimento de estoque existente com os dados fornecidos
         * @summary Atualiza um movimento de estoque
         * @param {number} id ID do movimento de estoque a ser atualizado
         * @param {MovimentoEstoque} movimentoEstoque 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovimento: async (id: number, movimentoEstoque: MovimentoEstoque, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMovimento', 'id', id)
            // verify required parameter 'movimentoEstoque' is not null or undefined
            assertParamExists('updateMovimento', 'movimentoEstoque', movimentoEstoque)
            const localVarPath = `/movimentos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movimentoEstoque, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MovimentosDeEstoqueApi - functional programming interface
 * @export
 */
export const MovimentosDeEstoqueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MovimentosDeEstoqueApiAxiosParamCreator(configuration)
    return {
        /**
         * Cria um novo movimento de estoque com os dados fornecidos
         * @summary Cria um novo movimento de estoque
         * @param {MovimentoEstoque} movimentoEstoque 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMovimento(movimentoEstoque: MovimentoEstoque, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MovimentoEstoque>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMovimento(movimentoEstoque, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MovimentosDeEstoqueApi.createMovimento']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exclui um movimento de estoque existente pelo seu ID
         * @summary Exclui um movimento de estoque
         * @param {number} id ID do movimento de estoque a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMovimento(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMovimento(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MovimentosDeEstoqueApi.deleteMovimento']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna uma lista com todos os movimentos de estoque cadastrados
         * @summary Busca todos os movimentos de estoque
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMovimentos(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MovimentoEstoque>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMovimentos(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MovimentosDeEstoqueApi.findAllMovimentos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna um movimento de estoque específico pelo seu ID
         * @summary Busca um movimento de estoque pelo ID
         * @param {number} id ID do movimento de estoque a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMovimentoById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MovimentoEstoque>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMovimentoById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MovimentosDeEstoqueApi.findMovimentoById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Atualiza um movimento de estoque existente com os dados fornecidos
         * @summary Atualiza um movimento de estoque
         * @param {number} id ID do movimento de estoque a ser atualizado
         * @param {MovimentoEstoque} movimentoEstoque 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMovimento(id: number, movimentoEstoque: MovimentoEstoque, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MovimentoEstoque>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMovimento(id, movimentoEstoque, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MovimentosDeEstoqueApi.updateMovimento']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MovimentosDeEstoqueApi - factory interface
 * @export
 */
export const MovimentosDeEstoqueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MovimentosDeEstoqueApiFp(configuration)
    return {
        /**
         * Cria um novo movimento de estoque com os dados fornecidos
         * @summary Cria um novo movimento de estoque
         * @param {MovimentoEstoque} movimentoEstoque 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovimento(movimentoEstoque: MovimentoEstoque, options?: RawAxiosRequestConfig): AxiosPromise<MovimentoEstoque> {
            return localVarFp.createMovimento(movimentoEstoque, options).then((request) => request(axios, basePath));
        },
        /**
         * Exclui um movimento de estoque existente pelo seu ID
         * @summary Exclui um movimento de estoque
         * @param {number} id ID do movimento de estoque a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMovimento(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMovimento(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna uma lista com todos os movimentos de estoque cadastrados
         * @summary Busca todos os movimentos de estoque
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMovimentos(options?: RawAxiosRequestConfig): AxiosPromise<MovimentoEstoque> {
            return localVarFp.findAllMovimentos(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna um movimento de estoque específico pelo seu ID
         * @summary Busca um movimento de estoque pelo ID
         * @param {number} id ID do movimento de estoque a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovimentoById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MovimentoEstoque> {
            return localVarFp.findMovimentoById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Atualiza um movimento de estoque existente com os dados fornecidos
         * @summary Atualiza um movimento de estoque
         * @param {number} id ID do movimento de estoque a ser atualizado
         * @param {MovimentoEstoque} movimentoEstoque 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovimento(id: number, movimentoEstoque: MovimentoEstoque, options?: RawAxiosRequestConfig): AxiosPromise<MovimentoEstoque> {
            return localVarFp.updateMovimento(id, movimentoEstoque, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MovimentosDeEstoqueApi - object-oriented interface
 * @export
 * @class MovimentosDeEstoqueApi
 * @extends {BaseAPI}
 */
export class MovimentosDeEstoqueApi extends BaseAPI {
    /**
     * Cria um novo movimento de estoque com os dados fornecidos
     * @summary Cria um novo movimento de estoque
     * @param {MovimentoEstoque} movimentoEstoque 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovimentosDeEstoqueApi
     */
    public createMovimento(movimentoEstoque: MovimentoEstoque, options?: RawAxiosRequestConfig) {
        return MovimentosDeEstoqueApiFp(this.configuration).createMovimento(movimentoEstoque, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exclui um movimento de estoque existente pelo seu ID
     * @summary Exclui um movimento de estoque
     * @param {number} id ID do movimento de estoque a ser excluído
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovimentosDeEstoqueApi
     */
    public deleteMovimento(id: number, options?: RawAxiosRequestConfig) {
        return MovimentosDeEstoqueApiFp(this.configuration).deleteMovimento(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna uma lista com todos os movimentos de estoque cadastrados
     * @summary Busca todos os movimentos de estoque
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovimentosDeEstoqueApi
     */
    public findAllMovimentos(options?: RawAxiosRequestConfig) {
        return MovimentosDeEstoqueApiFp(this.configuration).findAllMovimentos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna um movimento de estoque específico pelo seu ID
     * @summary Busca um movimento de estoque pelo ID
     * @param {number} id ID do movimento de estoque a ser buscado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovimentosDeEstoqueApi
     */
    public findMovimentoById(id: number, options?: RawAxiosRequestConfig) {
        return MovimentosDeEstoqueApiFp(this.configuration).findMovimentoById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Atualiza um movimento de estoque existente com os dados fornecidos
     * @summary Atualiza um movimento de estoque
     * @param {number} id ID do movimento de estoque a ser atualizado
     * @param {MovimentoEstoque} movimentoEstoque 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovimentosDeEstoqueApi
     */
    public updateMovimento(id: number, movimentoEstoque: MovimentoEstoque, options?: RawAxiosRequestConfig) {
        return MovimentosDeEstoqueApiFp(this.configuration).updateMovimento(id, movimentoEstoque, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProdutosApi - axios parameter creator
 * @export
 */
export const ProdutosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cria um novo produto com os dados fornecidos
         * @summary Cria um novo produto
         * @param {ProdutoDTO} produtoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduto: async (produtoDTO: ProdutoDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'produtoDTO' is not null or undefined
            assertParamExists('createProduto', 'produtoDTO', produtoDTO)
            const localVarPath = `/produtos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(produtoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exclui um produto existente pelo seu ID
         * @summary Exclui um produto
         * @param {number} id ID do produto a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduto: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduto', 'id', id)
            const localVarPath = `/produtos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna uma lista com todos os produtos cadastrados
         * @summary Busca todos os produtos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllProdutos: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/produtos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna um produto específico pelo seu ID
         * @summary Busca um produto pelo ID
         * @param {number} id ID do produto a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProdutoById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findProdutoById', 'id', id)
            const localVarPath = `/produtos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Atualiza um produto existente com os dados fornecidos
         * @summary Atualiza um produto
         * @param {number} id ID do produto a ser atualizado
         * @param {ProdutoDTO} produtoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduto: async (id: number, produtoDTO: ProdutoDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduto', 'id', id)
            // verify required parameter 'produtoDTO' is not null or undefined
            assertParamExists('updateProduto', 'produtoDTO', produtoDTO)
            const localVarPath = `/produtos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(produtoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProdutosApi - functional programming interface
 * @export
 */
export const ProdutosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProdutosApiAxiosParamCreator(configuration)
    return {
        /**
         * Cria um novo produto com os dados fornecidos
         * @summary Cria um novo produto
         * @param {ProdutoDTO} produtoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduto(produtoDTO: ProdutoDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduto(produtoDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProdutosApi.createProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exclui um produto existente pelo seu ID
         * @summary Exclui um produto
         * @param {number} id ID do produto a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduto(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduto(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProdutosApi.deleteProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna uma lista com todos os produtos cadastrados
         * @summary Busca todos os produtos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllProdutos(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllProdutos(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProdutosApi.findAllProdutos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna um produto específico pelo seu ID
         * @summary Busca um produto pelo ID
         * @param {number} id ID do produto a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProdutoById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProdutoById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProdutosApi.findProdutoById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Atualiza um produto existente com os dados fornecidos
         * @summary Atualiza um produto
         * @param {number} id ID do produto a ser atualizado
         * @param {ProdutoDTO} produtoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduto(id: number, produtoDTO: ProdutoDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduto(id, produtoDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProdutosApi.updateProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProdutosApi - factory interface
 * @export
 */
export const ProdutosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProdutosApiFp(configuration)
    return {
        /**
         * Cria um novo produto com os dados fornecidos
         * @summary Cria um novo produto
         * @param {ProdutoDTO} produtoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduto(produtoDTO: ProdutoDTO, options?: RawAxiosRequestConfig): AxiosPromise<ProdutoDTO> {
            return localVarFp.createProduto(produtoDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Exclui um produto existente pelo seu ID
         * @summary Exclui um produto
         * @param {number} id ID do produto a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduto(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProduto(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna uma lista com todos os produtos cadastrados
         * @summary Busca todos os produtos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllProdutos(options?: RawAxiosRequestConfig): AxiosPromise<ProdutoDTO> {
            return localVarFp.findAllProdutos(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna um produto específico pelo seu ID
         * @summary Busca um produto pelo ID
         * @param {number} id ID do produto a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProdutoById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ProdutoDTO> {
            return localVarFp.findProdutoById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Atualiza um produto existente com os dados fornecidos
         * @summary Atualiza um produto
         * @param {number} id ID do produto a ser atualizado
         * @param {ProdutoDTO} produtoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduto(id: number, produtoDTO: ProdutoDTO, options?: RawAxiosRequestConfig): AxiosPromise<ProdutoDTO> {
            return localVarFp.updateProduto(id, produtoDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProdutosApi - object-oriented interface
 * @export
 * @class ProdutosApi
 * @extends {BaseAPI}
 */
export class ProdutosApi extends BaseAPI {
    /**
     * Cria um novo produto com os dados fornecidos
     * @summary Cria um novo produto
     * @param {ProdutoDTO} produtoDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProdutosApi
     */
    public createProduto(produtoDTO: ProdutoDTO, options?: RawAxiosRequestConfig) {
        return ProdutosApiFp(this.configuration).createProduto(produtoDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exclui um produto existente pelo seu ID
     * @summary Exclui um produto
     * @param {number} id ID do produto a ser excluído
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProdutosApi
     */
    public deleteProduto(id: number, options?: RawAxiosRequestConfig) {
        return ProdutosApiFp(this.configuration).deleteProduto(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna uma lista com todos os produtos cadastrados
     * @summary Busca todos os produtos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProdutosApi
     */
    public findAllProdutos(options?: RawAxiosRequestConfig) {
        return ProdutosApiFp(this.configuration).findAllProdutos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna um produto específico pelo seu ID
     * @summary Busca um produto pelo ID
     * @param {number} id ID do produto a ser buscado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProdutosApi
     */
    public findProdutoById(id: number, options?: RawAxiosRequestConfig) {
        return ProdutosApiFp(this.configuration).findProdutoById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Atualiza um produto existente com os dados fornecidos
     * @summary Atualiza um produto
     * @param {number} id ID do produto a ser atualizado
     * @param {ProdutoDTO} produtoDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProdutosApi
     */
    public updateProduto(id: number, produtoDTO: ProdutoDTO, options?: RawAxiosRequestConfig) {
        return ProdutosApiFp(this.configuration).updateProduto(id, produtoDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RelatriosApi - axios parameter creator
 * @export
 */
export const RelatriosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retorna uma lista com ID/descrição do produto, total de unidades vendidas e lucro total
         * @summary Gera relatório de lucro por produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerarRelatorioLucroPorProduto: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relatorios/lucro-por-produto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna uma lista de produtos do tipo especificado, com quantidade total de saídas e estoque atual
         * @summary Gera relatório de produtos por tipo
         * @param {number} tipoProdutoId ID do tipo de produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerarRelatorioProdutosPorTipo: async (tipoProdutoId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tipoProdutoId' is not null or undefined
            assertParamExists('gerarRelatorioProdutosPorTipo', 'tipoProdutoId', tipoProdutoId)
            const localVarPath = `/relatorios/produtos-por-tipo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tipoProdutoId !== undefined) {
                localVarQueryParameter['tipoProdutoId'] = tipoProdutoId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelatriosApi - functional programming interface
 * @export
 */
export const RelatriosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelatriosApiAxiosParamCreator(configuration)
    return {
        /**
         * Retorna uma lista com ID/descrição do produto, total de unidades vendidas e lucro total
         * @summary Gera relatório de lucro por produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gerarRelatorioLucroPorProduto(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LucroPorProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gerarRelatorioLucroPorProduto(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelatriosApi.gerarRelatorioLucroPorProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna uma lista de produtos do tipo especificado, com quantidade total de saídas e estoque atual
         * @summary Gera relatório de produtos por tipo
         * @param {number} tipoProdutoId ID do tipo de produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gerarRelatorioProdutosPorTipo(tipoProdutoId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProdutoPorTipoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gerarRelatorioProdutosPorTipo(tipoProdutoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelatriosApi.gerarRelatorioProdutosPorTipo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RelatriosApi - factory interface
 * @export
 */
export const RelatriosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelatriosApiFp(configuration)
    return {
        /**
         * Retorna uma lista com ID/descrição do produto, total de unidades vendidas e lucro total
         * @summary Gera relatório de lucro por produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerarRelatorioLucroPorProduto(options?: RawAxiosRequestConfig): AxiosPromise<LucroPorProdutoDTO> {
            return localVarFp.gerarRelatorioLucroPorProduto(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna uma lista de produtos do tipo especificado, com quantidade total de saídas e estoque atual
         * @summary Gera relatório de produtos por tipo
         * @param {number} tipoProdutoId ID do tipo de produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerarRelatorioProdutosPorTipo(tipoProdutoId: number, options?: RawAxiosRequestConfig): AxiosPromise<ProdutoPorTipoDTO> {
            return localVarFp.gerarRelatorioProdutosPorTipo(tipoProdutoId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelatriosApi - object-oriented interface
 * @export
 * @class RelatriosApi
 * @extends {BaseAPI}
 */
export class RelatriosApi extends BaseAPI {
    /**
     * Retorna uma lista com ID/descrição do produto, total de unidades vendidas e lucro total
     * @summary Gera relatório de lucro por produto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatriosApi
     */
    public gerarRelatorioLucroPorProduto(options?: RawAxiosRequestConfig) {
        return RelatriosApiFp(this.configuration).gerarRelatorioLucroPorProduto(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna uma lista de produtos do tipo especificado, com quantidade total de saídas e estoque atual
     * @summary Gera relatório de produtos por tipo
     * @param {number} tipoProdutoId ID do tipo de produto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatriosApi
     */
    public gerarRelatorioProdutosPorTipo(tipoProdutoId: number, options?: RawAxiosRequestConfig) {
        return RelatriosApiFp(this.configuration).gerarRelatorioProdutosPorTipo(tipoProdutoId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TiposDeProdutoApi - axios parameter creator
 * @export
 */
export const TiposDeProdutoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cria um novo tipo de produto com os dados fornecidos
         * @summary Cria um novo tipo de produto
         * @param {TipoProdutoDTO} tipoProdutoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTipoProduto: async (tipoProdutoDTO: TipoProdutoDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tipoProdutoDTO' is not null or undefined
            assertParamExists('createTipoProduto', 'tipoProdutoDTO', tipoProdutoDTO)
            const localVarPath = `/tipos-produto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tipoProdutoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exclui um tipo de produto existente pelo seu ID
         * @summary Exclui um tipo de produto
         * @param {number} id ID do tipo de produto a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTipoProduto: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTipoProduto', 'id', id)
            const localVarPath = `/tipos-produto/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna uma lista com todos os tipos de produto cadastrados
         * @summary Busca todos os tipos de produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTiposProduto: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tipos-produto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna um tipo de produto específico pelo seu ID
         * @summary Busca um tipo de produto pelo ID
         * @param {number} id ID do tipo de produto a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTipoProdutoById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTipoProdutoById', 'id', id)
            const localVarPath = `/tipos-produto/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Atualiza um tipo de produto existente com os dados fornecidos
         * @summary Atualiza um tipo de produto
         * @param {number} id ID do tipo de produto a ser atualizado
         * @param {TipoProdutoDTO} tipoProdutoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTipoProduto: async (id: number, tipoProdutoDTO: TipoProdutoDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTipoProduto', 'id', id)
            // verify required parameter 'tipoProdutoDTO' is not null or undefined
            assertParamExists('updateTipoProduto', 'tipoProdutoDTO', tipoProdutoDTO)
            const localVarPath = `/tipos-produto/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tipoProdutoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiposDeProdutoApi - functional programming interface
 * @export
 */
export const TiposDeProdutoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TiposDeProdutoApiAxiosParamCreator(configuration)
    return {
        /**
         * Cria um novo tipo de produto com os dados fornecidos
         * @summary Cria um novo tipo de produto
         * @param {TipoProdutoDTO} tipoProdutoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTipoProduto(tipoProdutoDTO: TipoProdutoDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipoProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTipoProduto(tipoProdutoDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiposDeProdutoApi.createTipoProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exclui um tipo de produto existente pelo seu ID
         * @summary Exclui um tipo de produto
         * @param {number} id ID do tipo de produto a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTipoProduto(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTipoProduto(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiposDeProdutoApi.deleteTipoProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna uma lista com todos os tipos de produto cadastrados
         * @summary Busca todos os tipos de produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTiposProduto(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipoProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTiposProduto(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiposDeProdutoApi.findAllTiposProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna um tipo de produto específico pelo seu ID
         * @summary Busca um tipo de produto pelo ID
         * @param {number} id ID do tipo de produto a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTipoProdutoById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipoProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTipoProdutoById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiposDeProdutoApi.findTipoProdutoById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Atualiza um tipo de produto existente com os dados fornecidos
         * @summary Atualiza um tipo de produto
         * @param {number} id ID do tipo de produto a ser atualizado
         * @param {TipoProdutoDTO} tipoProdutoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTipoProduto(id: number, tipoProdutoDTO: TipoProdutoDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipoProdutoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTipoProduto(id, tipoProdutoDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiposDeProdutoApi.updateTipoProduto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TiposDeProdutoApi - factory interface
 * @export
 */
export const TiposDeProdutoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TiposDeProdutoApiFp(configuration)
    return {
        /**
         * Cria um novo tipo de produto com os dados fornecidos
         * @summary Cria um novo tipo de produto
         * @param {TipoProdutoDTO} tipoProdutoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTipoProduto(tipoProdutoDTO: TipoProdutoDTO, options?: RawAxiosRequestConfig): AxiosPromise<TipoProdutoDTO> {
            return localVarFp.createTipoProduto(tipoProdutoDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Exclui um tipo de produto existente pelo seu ID
         * @summary Exclui um tipo de produto
         * @param {number} id ID do tipo de produto a ser excluído
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTipoProduto(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTipoProduto(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna uma lista com todos os tipos de produto cadastrados
         * @summary Busca todos os tipos de produto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTiposProduto(options?: RawAxiosRequestConfig): AxiosPromise<TipoProdutoDTO> {
            return localVarFp.findAllTiposProduto(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna um tipo de produto específico pelo seu ID
         * @summary Busca um tipo de produto pelo ID
         * @param {number} id ID do tipo de produto a ser buscado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTipoProdutoById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<TipoProdutoDTO> {
            return localVarFp.findTipoProdutoById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Atualiza um tipo de produto existente com os dados fornecidos
         * @summary Atualiza um tipo de produto
         * @param {number} id ID do tipo de produto a ser atualizado
         * @param {TipoProdutoDTO} tipoProdutoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTipoProduto(id: number, tipoProdutoDTO: TipoProdutoDTO, options?: RawAxiosRequestConfig): AxiosPromise<TipoProdutoDTO> {
            return localVarFp.updateTipoProduto(id, tipoProdutoDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TiposDeProdutoApi - object-oriented interface
 * @export
 * @class TiposDeProdutoApi
 * @extends {BaseAPI}
 */
export class TiposDeProdutoApi extends BaseAPI {
    /**
     * Cria um novo tipo de produto com os dados fornecidos
     * @summary Cria um novo tipo de produto
     * @param {TipoProdutoDTO} tipoProdutoDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposDeProdutoApi
     */
    public createTipoProduto(tipoProdutoDTO: TipoProdutoDTO, options?: RawAxiosRequestConfig) {
        return TiposDeProdutoApiFp(this.configuration).createTipoProduto(tipoProdutoDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exclui um tipo de produto existente pelo seu ID
     * @summary Exclui um tipo de produto
     * @param {number} id ID do tipo de produto a ser excluído
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposDeProdutoApi
     */
    public deleteTipoProduto(id: number, options?: RawAxiosRequestConfig) {
        return TiposDeProdutoApiFp(this.configuration).deleteTipoProduto(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna uma lista com todos os tipos de produto cadastrados
     * @summary Busca todos os tipos de produto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposDeProdutoApi
     */
    public findAllTiposProduto(options?: RawAxiosRequestConfig) {
        return TiposDeProdutoApiFp(this.configuration).findAllTiposProduto(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna um tipo de produto específico pelo seu ID
     * @summary Busca um tipo de produto pelo ID
     * @param {number} id ID do tipo de produto a ser buscado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposDeProdutoApi
     */
    public findTipoProdutoById(id: number, options?: RawAxiosRequestConfig) {
        return TiposDeProdutoApiFp(this.configuration).findTipoProdutoById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Atualiza um tipo de produto existente com os dados fornecidos
     * @summary Atualiza um tipo de produto
     * @param {number} id ID do tipo de produto a ser atualizado
     * @param {TipoProdutoDTO} tipoProdutoDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposDeProdutoApi
     */
    public updateTipoProduto(id: number, tipoProdutoDTO: TipoProdutoDTO, options?: RawAxiosRequestConfig) {
        return TiposDeProdutoApiFp(this.configuration).updateTipoProduto(id, tipoProdutoDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



